{
	"macros": {
		"prefix": "mac",
		"body": [
		  "/*",
		  "~~~JsCode~~~",
		  "*/",
		  "#include <bits/stdc++.h>",
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "using namespace std;",
		  "template<class T> using oset=tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update> ;",
		  "template<class T> using hmax=priority_queue<T>;",
		  "template<class T> using hmin=priority_queue<T,vector<T>,greater<T>>;",
		  "#define ll long long",
		  "#define ldb long double",
		  "#define pb push_back",
		  "#define all(v) (v).begin(),(v).end()",
		  "#define tr(i,a) for(auto& i:(a))",
		  "#define fr(i,a,b) for(int i=(a);i<(b);++i)",
		  "#define frv(i,a,b) for(int i=(a);i>=(b);--i)",
		  "#define ar(n) array<int,n>",
		  "#define ve vector",
		  "#define vi ve<int>",
		  "//#define int ll",
		  "const int MOD = 1000000007, MOD2 = 998244353;",
		  "const int MAX=1e5;",
		  "",
		  "void solve(){",
		  "    int n;",
		  "    cin>>n;",
		  "}",
		  "",
		  "int32_t main(){",
		  "    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);",
		  "    #ifdef LOCAL_JUDGE",
		  "        auto start = chrono::high_resolution_clock::now();",
		  "        freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);",
		  "    #endif",
		  "    //INIT",
		  "    int t=1;",
		  "    cin>>t;",
		  "    for(int i=1;i<=t;i++){",
		  "        //cout<<\"Case #\"<<i<<\": \";",
		  "        solve();",
		  "    }",
		  "    #ifdef LOCAL_JUDGE",
		  "        auto stop = chrono::high_resolution_clock::now();",
		  "        auto duration = chrono::duration_cast<chrono::microseconds>(stop - start);",
		  "        cerr << \"Time taken : \" << duration.count() / 1000000.0 << \"seconds\"<< \"\\n\";",
		  "    #endif",
		  "    return 0;",
		  "}"
		],
		"description": "macros"
	  },
	"sieve with segmentation": {
		"prefix": "segsieve",
		"body": [
			"void sieve(ll l,ll r){",
			"    int m=sqrt(r);",
			"    vector<bool> temp(m+1,1),pr(r-l+1,1);",
			"    for(int i=2;i*i<=m;i++){",
			"        if(temp[i]){",
			"            for(int j=i*i;j<=m;j+=i) temp[j]=0;",
			"        }",
			"    }",
			"    for(int i=2;i<=m;i++){",
			"        if(temp[i]){",
			"            int x=l/i*i;",
			"            if(x<l) x+=i;",
			"            for(ll j=x;j<=r;j+=i) pr[j-l]=0;",
			"        }",
			"    }",
			"}"
		],
		"description": "sieve with segmentation"
	},
	"segment trees": {
		"prefix": "segtree",
		"body": [
			"template<class T>",
			"class SegTree{",
			"    int n,size;",
			"    vector<T> seg;",
			"    T (*combine)(T,T);",
			"    T get(int,int,int,int,int=0);",
			"    T update(int,int,int,T,int=0);",
			"    public:",
			"    SegTree(vector<T> a,T (*combine)(T,T)){",
			"        n=a.size(),size=pow(2,ceil(log2(n))+1)-1,this->combine=combine;",
			"        seg.assign(size,0);",
			"        for(int i=0;i<n;i++) update(i,a[i]);",
			"    }",
			"    void print(){ tr(e,seg) cout<<e<<\" \";cout<<\"\\n\"; }",
			"    T get(int l,int r){ return get(0,n-1,l,r); }",
			"    T update(int i,T val){ return update(0,n-1,i,val); }",
			"};",
			"template <class T>",
			"T SegTree<T>::get(int l,int r,int ql, int qr, int i){",
			"    if(qr<l||ql>r) return 0;",
			"    if(qr>=r&&ql<=l) return seg[i];",
			"    int m=l+(r-l)/2;",
			"    return combine(get(l,m,ql,qr,i*2+1),get(m+1,r,ql,qr,i*2+2));",
			"}",
			"template <class T>",
			"T SegTree<T>::update(int l,int r,int q,T val,int i){",
			"    if(l==r) return seg[i]=val;",
			"    int m=l+(r-l)/2;",
			"    if(q<=m) return seg[i]=combine(update(l,m,q,val,i*2+1),seg[i*2+2]);",
			"    else return seg[i]=combine(seg[i*2+1],update(m+1,r,q,val,i*2+2));",
			"}"
		],
		"description": "segment trees"
	},
	"segment trees with lazy propagation": {
		"prefix": "segtreelazy",
		"body": [
			"template<class T>",
			"class SegTree{",
			"    vector<T> seg,lazy;",
			"    int n,size;",
			"    T (*combine)(T,T);",
			"    T get(int,int,int,int,int=0);",
			"    T update(int,int,int,T,int=0);",
			"    T rangeUpdate(int,int,int,int,T,int=0);",
			"    void upd(int,int,int);",
			"    public:",
			"    SegTree(vector<T> a,T (*combine)(T,T)){",
			"        n=a.size(),size=pow(2,ceil(log2(n))+1)-1,this->combine=combine;",
			"        lazy.assign(size,0),seg.assign(size,0);",
			"        for(int i=0;i<n;i++) update(i,a[i]);",
			"    }",
			"    void print(){ tr(e,seg) cout<<e<<\" \";cout<<\"\\n\"; }",
			"    T get(int l,int r){ return get(0,n-1,l,r); }",
			"    T update(int i,T val) { return update(0,n-1,i,val); }",
			"    T rangeUpdate(int l,int r,T val){ return rangeUpdate(0,n-1,l,r,val); }",
			"};",
			"template<class T>",
			"void SegTree<T>::upd(int i,int l,int r){",
			"    if(lazy[i]!=0) {",
			"        seg[i]+=(r-l+1)*lazy[i];",
			"        if(l!=r) lazy[i*2+1]+=lazy[i],lazy[i*2+2]+=lazy[i];",
			"        lazy[i]=0;",
			"    }",
			"}",
			"template<class T>",
			"T SegTree<T>::get(int l,int r,int ql, int qr, int i){",
			"    upd(i,l,r);",
			"    if(qr<l||ql>r) return 0;",
			"    if(qr>=r&&ql<=l) return seg[i];",
			"    int m=l+(r-l)/2;",
			"    return combine(get(l,m,ql,qr,i*2+1),get(m+1,r,ql,qr,i*2+2));",
			"}",
			"template <class T>",
			"T SegTree<T>::update(int l,int r,int q,T val,int i){",
			"    if(l==r) return seg[i]=val;",
			"    int m=l+(r-l)/2;",
			"    if(q<=m) return seg[i]=combine(update(l,m,q,val,i*2+1),seg[i*2+2]);",
			"    else return seg[i]=combine(seg[i*2+1],update(m+1,r,q,val,i*2+2));",
			"}",
			"template<class T>",
			"T SegTree<T>::rangeUpdate(int l,int r,int ql,int qr,T val,int i){",
			"    upd(i,l,r);",
			"    if(l>qr || r<ql) return seg[i];",
			"    if(l>=ql && r<=qr) {",
			"        if(l!=r) lazy[i*2+1]+=val,lazy[i*2+2]+=val;",
			"        return seg[i]+=(r-l+1)*val;",
			"    }",
			"    int m=l+(r-l)/2;",
			"    return seg[i]=combine(rangeUpdate(l,m,ql,qr,val,i*2+1),rangeUpdate(m+1,r,ql,qr,val,i*2+2));",
			"}",
			""
		],
		"description": "segment trees with lazy propagation"
	},
	"Fenwick tree / BIT": {
		"prefix": "bit",
		"body": [
			"template<class T>",
			"class Bit{",
			"    int size;",
			"    vector<T> tree;",
			"    public:",
			"    Bit(vector<T> a){",
			"        size=a.size()+1;",
			"        tree.assign(size,0);",
			"        for(int i=0;i<size-1;i++) update(i,a[i]); ",
			"    }",
			"    T get(int);",
			"    void update(int,T);",
			"};",
			"template<class T>",
			"void Bit<T>::update(int i,T val){",
			"    i++;",
			"    while(i<size) tree[i]+=val,i+=(i&(-i));",
			"}",
			"template<class T>",
			"T Bit<T>::get(int i){",
			"    T res=0;i++;",
			"    while(i>0) res+=tree[i],i-=(i&(-i));",
			"    return res; ",
			"}"
		],
		"description": "Fenwick tree / BIT"
	}
}
