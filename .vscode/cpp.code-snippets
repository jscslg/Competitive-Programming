{
	"": {
		"prefix": "mac",
		"body": [
		  "/*",
		  "~~~JsCode~~~",
		  "*/",
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "#define ll long long",
		  "#define ldb long double",
		  "#define pb push_back",
		  "#define F first",
		  "#define S second",
		  "#define all(v) (v).begin(),(v).end()",
		  "#define tr(i,a) for(auto& i:(a))",
		  "#define fr(i,a,b) for(int i=(a);i<(b);++i)",
		  "#define frv(i,a,b) for(int i=(a);i>=(b);--i)",
		  "#define vi vector<int>",
		  "#define vvi vector<vi>",
		  "#define ii pair<int,int>",
		  "#define iii pair<int,ii>",
		  "#define vii vector<ii>",
		  "#define hmax priority_queue<int>",
		  "#define hmin priority_queue<int,vi,greater<int>>",
		  "#define MOD 1000000007",
		  "//#define int ll",
		  "int MAX=1e5;",
		  "",
		  "void solve(){",
		  "    ",
		  "}",
		  "",
		  "int32_t main(){",
		  "    ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);",
		  "    #ifdef LOCAL_JUDGE",
		  "    freopen(\"input.txt\", \"r\", stdin);freopen(\"output.txt\", \"w\", stdout);",
		  "    #endif",
		  "    //INIT",
		  "    int t=1;",
		  "    cin>>t;",
		  "    for(int i=1;i<=t;i++){",
		  "        //cout<<\"Case #\"<<i<<\": \";",
		  "        solve();",
		  "    }",
		  "    return 0;",
		  "}"
		],
		"description": ""
	  },
	"power mod m": {
		"prefix": "powm",
		"body": [
		  "ll powm(ll number,ll exponent=MOD-2){",
		  "    ll ret=1;",
		  "    while(exponent>0){",
		  "        if(exponent&1) ret=(ret*number)%MOD;",
		  "        exponent>>=1,number=(number*number)%MOD;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "power mod m"
	  },
	  "power logr": {
		"prefix": "powr",
		"body": [
		  "ll powr(ll number,ll exponent){",
		  "    ll ret=1;",
		  "    while(exponent>0){",
		  "        if(exponent&1) ret*=number;",
		  "        exponent>>=1,number*=number;",
		  "    }",
		  "    return ret;",
		  "}"
		],
		"description": "power"
	  },
	  "sieve": {
		"prefix": "sieve",
		"body": [
	 	  "pr = vector<int>(MAX+1,1);",
		  "for(int i=2;i*i<=MAX;i++){",
		  "    if(pr[i]){",
		  "        for(int j=i*i;j<=MAX;j+=i) pr[j]=0;",
		  "    }",
		  "}"
		],
		"description": "sieve"
	  },
	  "sieve with factorisation": {
		"prefix": "fsieve",
		"body": [
		  "pr = vector<int>(MAX+1,1);",
		  "for(int i=2;i*i<=MAX;i++){",
		  "    if(pr[i]==1){",
		  "        for(int j=i*i;j<=MAX;j+=i) if(pr[j]==1) pr[j]=i;",
		  "    }",
		  "}"
		],
		"description": "sieve with factorisation"
	  },
	  "sieve with segmentation": {
		"prefix": "segsieve",
		"body": [
		  "void sieve(ll l,ll r){",
		  "    int m=sqrt(r);",
		  "    vector<bool> temp(m+1,1),pr(r-l+1,1);",
		  "    for(int i=2;i*i<=m;i++){",
		  "        if(temp[i]){",
		  "            for(int j=i*i;j<=m;j+=i) temp[j]=0;",
		  "        }",
		  "    }",
		  "    for(int i=2;i<=m;i++){",
		  "        if(temp[i]){",
		  "            int x=l/i*i;",
		  "            if(x<l) x+=i;",
		  "            for(ll j=x;j<=r;j+=i) pr[j-l]=0;",
		  "        }",
		  "    }",
		  "}"
		],
		"description": "sieve with segmentation"
	  },
	  "segment trees": {
		"prefix": "segtree",
		"body": [
		  "template<class T>",
		  "class SegTree{",
		  "    int n,size;",
		  "    vector<T> seg;",
		  "    T (*combine)(T,T);",
		  "    T get(int,int,int,int,int=0);",
		  "    T update(int,int,int,T,int=0);",
		  "    public:",
		  "    SegTree(vector<T> a,T (*combine)(T,T)){",
		  "        n=a.size(),size=pow(2,ceil(log2(n))+1)-1,this->combine=combine;",
		  "        seg.assign(size,0);",
		  "        for(int i=0;i<n;i++) update(i,a[i]);",
		  "    }",
		  "    void print(){ tr(e,seg) cout<<e<<\" \";cout<<\"\\n\"; }",
		  "    T get(int l,int r){ return get(0,n-1,l,r); }",
		  "    T update(int i,T val){ return update(0,n-1,i,val); }",
		  "};",
		  "template <class T>",
		  "T SegTree<T>::get(int l,int r,int ql, int qr, int i){",
		  "    if(qr<l||ql>r) return 0;",
		  "    if(qr>=r&&ql<=l) return seg[i];",
		  "    int m=l+(r-l)/2;",
		  "    return combine(get(l,m,ql,qr,i*2+1),get(m+1,r,ql,qr,i*2+2));",
		  "}",
		  "template <class T>",
		  "T SegTree<T>::update(int l,int r,int q,T val,int i){",
		  "    if(l==r) return seg[i]=val;",
		  "    int m=l+(r-l)/2;",
		  "    if(q<=m) return seg[i]=combine(update(l,m,q,val,i*2+1),seg[i*2+2]);",
		  "    else return seg[i]=combine(seg[i*2+1],update(m+1,r,q,val,i*2+2));",
		  "}"
		],
		"description": "segment trees"
	  },
	  "segment trees with lazy propagation": {
		"prefix": "segtreelazy",
		"body": [
		  "template<class T>",
		  "class SegTree{",
		  "    vector<T> seg,lazy;",
		  "    int n,size;",
		  "    T (*combine)(T,T);",
		  "    T get(int,int,int,int,int=0);",
		  "    T update(int,int,int,T,int=0);",
		  "    T rangeUpdate(int,int,int,int,T,int=0);",
		  "    void upd(int,int,int);",
		  "    public:",
		  "    SegTree(vector<T> a,T (*combine)(T,T)){",
		  "        n=a.size(),size=pow(2,ceil(log2(n))+1)-1,this->combine=combine;",
		  "        lazy.assign(size,0),seg.assign(size,0);",
		  "        for(int i=0;i<n;i++) update(i,a[i]);",
		  "    }",
		  "    void print(){ tr(e,seg) cout<<e<<\" \";cout<<\"\\n\"; }",
		  "    T get(int l,int r){ return get(0,n-1,l,r); }",
		  "    T update(int i,T val) { return update(0,n-1,i,val); }",
		  "    T rangeUpdate(int l,int r,T val){ return rangeUpdate(0,n-1,l,r,val); }",
		  "};",
		  "template<class T>",
		  "void SegTree<T>::upd(int i,int l,int r){",
		  "    if(lazy[i]!=0) {",
		  "        seg[i]+=(r-l+1)*lazy[i];",
		  "        if(l!=r) lazy[i*2+1]+=lazy[i],lazy[i*2+2]+=lazy[i];",
		  "        lazy[i]=0;",
		  "    }",
		  "}",
		  "template<class T>",
		  "T SegTree<T>::get(int l,int r,int ql, int qr, int i){",
		  "    upd(i,l,r);",
		  "    if(qr<l||ql>r) return 0;",
		  "    if(qr>=r&&ql<=l) return seg[i];",
		  "    int m=l+(r-l)/2;",
		  "    return combine(get(l,m,ql,qr,i*2+1),get(m+1,r,ql,qr,i*2+2));",
		  "}",
		  "template <class T>",
		  "T SegTree<T>::update(int l,int r,int q,T val,int i){",
		  "    if(l==r) return seg[i]=val;",
		  "    int m=l+(r-l)/2;",
		  "    if(q<=m) return seg[i]=combine(update(l,m,q,val,i*2+1),seg[i*2+2]);",
		  "    else return seg[i]=combine(seg[i*2+1],update(m+1,r,q,val,i*2+2));",
		  "}",
		  "template<class T>",
		  "T SegTree<T>::rangeUpdate(int l,int r,int ql,int qr,T val,int i){",
		  "    upd(i,l,r);",
		  "    if(l>qr || r<ql) return seg[i];",
		  "    if(l>=ql && r<=qr) {",
		  "        if(l!=r) lazy[i*2+1]+=val,lazy[i*2+2]+=val;",
		  "        return seg[i]+=(r-l+1)*val;",
		  "    }",
		  "    int m=l+(r-l)/2;",
		  "    return seg[i]=combine(rangeUpdate(l,m,ql,qr,val,i*2+1),rangeUpdate(m+1,r,ql,qr,val,i*2+2));",
		  "}",
		  ""
		],
		"description": "segment trees with lazy propagation"
	  },
	  "Fenwick tree / BIT": {
		"prefix": "bit",
		"body": [
		  "template<class T>",
		  "class Bit{",
		  "    int size;",
		  "    vector<T> tree;",
		  "    public:",
		  "    Bit(vector<T> a){",
		  "        size=a.size()+1;",
		  "        tree.assign(size,0);",
		  "        for(int i=0;i<size-1;i++) update(i,a[i]); ",
		  "    }",
		  "    T get(int);",
		  "    void update(int,T);",
		  "};",
		  "template<class T>",
		  "void Bit<T>::update(int i,T val){",
		  "    i++;",
		  "    while(i<size) tree[i]+=val,i+=(i&(-i));",
		  "}",
		  "template<class T>",
		  "T Bit<T>::get(int i){",
		  "    T res=0;i++;",
		  "    while(i>0) res+=tree[i],i-=(i&(-i));",
		  "    return res; ",
		  "}"
		],
		"description": "Fenwick tree / BIT"
	  }
}